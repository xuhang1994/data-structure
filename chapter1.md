#第1章 引论

在这一章，我们阐述本书的目的和目标并简要复习离散数学以及程序设计的一些概念，我们将要看到：

- 看到程序在较大输入情况下的运行性能与在适量输入情况下的运行性能具有同等的重要性。

- 总结本书其余部分所需要的基本的数学基础。

- 简要复习递归。

# 1.1 本书主要讨论内容

设有一组$N$个数，并要求确定其中第$k$个最大者。我们将之称为**选择问题**（selection problem）。大多数学习过一两门程序设计课程的学生写一个解决这种问题的程序不会有什么困难。“显而易见”的解决方法就有很多。

该问题的一种解法就是将这$N$个数读进一个数组中，再通过某种简单的算法，比如冒泡排序法，以递减顺序将数组排序，然后返回位置$k$上的元素。

稍好一点的算法可以先把前$k$个元素读入数组并（以递减的顺序）对其进行排序。接着，将剩下的元素再逐个读入。当新元素被读到时，如果它小于数组中的第$k$个元素则忽略，否则就将其放到数组中正确的位置上，同时将数组中的一个元素挤出数组。当算法终止时，位于第$k$个位置上的元素作为答案返回。

这两种算法编码都很简单，建议读者可以进行尝试。此时我们自然要问：哪个算法更好？哪个算法更重要？还是两个算法都足够好？使用含有一百万个元素的随机文件，在$k=50000$的条件下进行模拟，可以发现，两个算法在合理的时间量内均不可以结束；每种算法都需要计算机处理若干天才能算完（虽然最后还是给出了正确的答案）。在第7章将讨论另外一种算法，该算法将在一秒钟左右给出问题的解。因此，虽然我们提出的两个算法都能计算出结果，但是它们不能被认为是好的算法。因此对于第三种算法在合理的时间内能够处理的输入数据量而言，这两种算法是不切实际的。

第二个问题是解决一个流行的字谜。输入是由一些字幕和单词的二维数组组成。目标是要找出字谜中的单词，这些单词可能是水平、垂直或沿对角线以任何方向放置的。作为例子，图1-1所示的字谜由单词$this、two、fat$和$that$组成。单词$this$从第一行第一列的位置即（1，1）处开始并延伸至（1，4）；单词$two$从（1，1）到（3，1）；$fat$从（4，1）到（2，3）；而$that$从（4，4）到（1，1）。

\begin{array}{c|lccr}
  & \text{1} & \text{2} & \text{3} & \text{4} \\
\hline
1 & c & h & i & s \\
2 & w & a & t & s \\
3 & o & a & h & g \\
4 & f & g & d & c
\end{array}

现在至少有两种直观算法来求解这个问题。对单词表中的每个单词，我们检查到每一个有序三元组（行、列、方向），验证是否有单词的存在。这需要大量嵌套的$for$循环，但它基本上是直观的算法。

也可以这样，对于每个尚未进行到字谜最后的有序四元组(行，列，方向，字符数）我们可以测试所指的单词是否在单词中。这也导致使用大量嵌套的$for$循环。如果在任意单词中的最大字符数已知，那么该算法有可能节省一些时间。

上述两种方法相对来说都不难编码并可求解发表于杂志上的许多现实的字谜游戏。这些字谜通常有16行16列以及40个左右的单词。然而，假设我们把字谜变成只给出**谜板**（puzzle board)而单词表基本上是一本英语词典，则上面提出的两种解法需要相当可观的时间来解决这个问题，故这两种方法都是不可以接受的。不过，这样的问题还是有可能在数秒内解决的，即使单词表很大也可以。

在许多问题当中，一个重要的观念是：写出一个可以工作的程序并不够。如果这个程序在巨大的数据集上运行，那么运行时间就变成了重要的问题。我们将在本书中看到对于大量的输入，如何估计程序的运行时间，尤其是如何在尚未具体编码的情况下比较两个程序的运行时间。我们还将看到彻底改进程序速度以及确定程序瓶颈的方法。这些方法将使我们能够找到需要大力优化的那些代码段。

### 1.2 数学知识复习

这一节列出一些需要记住或者是能够推导出的基本公式。复习基本的证明方法。

#### 1.2.1 指数

$$X^{A}X^{B}=X^{A+B}$$
$$\frac{X^{A}}{X^{B}}=X^{A-B}$$
$$(X^{A})^{B}=X^{AB}$$
$$X^{N}+X^{N}=2X^{N}\neq X^{2N}$$
$$2^{N}+2^{N}=2^{N+1}$$

#### 1.2.2 对数

在计算机科学中，除非有特别的声明，所有的对数都是以2为底的。

定义：$X^{A}=B$，当且仅当$\log_{X}B=A$

由该定义可以得到几个方便的等式。

**定理1.1**

$$\log_{A}B=\frac {\log_{C}B}{\log_{C}A}$$

**证明：**

令$X=\log_{C}B,Y=\log_{C}A$,以及$Z=\log_{A}B$。此时由对数的定义得：$C^{X}=B,C^{Y}=A$以及$A^{Z}=B$。联合这三个等式则产生$(C^{Y})^{Z}=C^{X}=B$。此时$X=YZ$，这意味着$Z=\frac XY$，定理得证。

**定理 1.2**

$$\log AB=\log A+\log B$$

**证明**

令$X=\log{A},Y=\log{B}$，以及$Z=\log{AB}$。此时由于假设默认的底为2，$2^{X}=A,2^{Y}=B$及$2^{Z}=AB$。联合最后的三个等式则有$2^{X}2^{Y}=2^{Z}=AB$。因此$X+Y=Z$，这就证明了该定理。

其他一些有用的公式如下，它们都能够用类似的方法推导。

$\log {\frac {A}{B}}=\log A-\log B$
$\log(A^{B})=B\log{A}$
$\log{X}＜X \text{(对所有的X＞0成立)}$
$\log{1}=0,\log{2}=1,\log{1024}=10,\log{1048576}=20$。

**1.2.3 级数**

最容易记忆的公式是

$$\sum_{i=0}^N {2^i}=2^{N+1}-1$$

和

$$\sum_{i=0}^N {A^i}=\frac {A^{N+1}-1}{A-1}$$

在第二个公式中，如果$0＜A＜1$，则

$$\sum_{i=0}^N {A^i} \leq \frac {1}{1-A}$$

当$N$趋向于$\infty$时该和趋向于$\frac {1}{1-A}$，这些公式是“几何集数”公式。

我们可以用下面的方法推导关于$\sum_{i=0}^{\infty} {A^i}\text{(0＜A＜1)}$的公式，令$S$表示和，此时

$$S=1+A+A^2+A^3+A^4+A^5+\cdots$$

于是

$$AS=A+A^2+A^3+A^4+A^5+\cdots$$

如果我们将这两个等式相减（这种运算只能对收敛级数进行），等号右边所有的项相消，只留下1：

$$S-AS=1$$

这就是说

$$S=\frac {1}{1-A}$$

可以用相同方法计算$\sum_{i=1}^{\infty} {\frac{i}{2^i}}$，它是一个经常出现的和。我们写成

$$S=\frac {1}{2}+\frac {2}{2^2}+\frac {3}{2^3}+\frac {4}{2^4}+\frac {5}{2^5}+\cdots$$

用2乘之得到

$$2S=1+\frac {2}{2}+\frac {3}{2^2}+\frac {4}{2^3}+\frac {5}{2^4}+\frac {6}{2^5}+\cdots$$

将这两个方程相减得到

$$S=\frac {1}{2}+\frac {1}{2^2}+\frac {1}{2^3}+\frac {1}{2^4}+\frac {1}{2^5}+\cdots$$

因此，$S=2$。

分析中另一种常用类型的级数是算数级数。任何这样的级数都可以通过基本公式计算其值。

$$\sum_{i=1}^N {i}=\frac {N(N+1)}{2}\approx \frac {N^2}{2}$$

例如，为求出和$2+5+8+\cdots+(3k-1)$,将其改写为$3(1+2+3+\cdots+k)-(1+1+1+\cdots+1)$，显然，它就是$\frac {3k(k+1)}{2}-k$。另一种记忆的方法则是将第一项与最后一项相加（和为$3k+1$)，第二项与倒数第二项相加（和也是$3k+1$），等等。由于有$\frac {k}{2}$个这样的数对，因此总和就是$\frac {3k(k+1)}{2}$，这与前面的答案相同。

现在介绍下面两个公式，它们就没那么常见了。

$$\sum_{i=1}^N {i^2}=\frac {N(N+1)(2N+1)}{6}\approx \frac {N^3}{3}$$
$$\sum_{i=1}^N {i^k}\approx \frac {N^{k+1}}{\mid k+1\mid}  ( k\neq -1)$$

当$k=-1$时，后一个的公式不成立。此时我们需要下面的公式，这个公式在计算机科学中的使用要远比在数学其他科目中使用得多。数$H_{N}$叫做调和数，其和叫做调和和。下面近似式中的误差趋向于$\gamma\approx 0.57721566$，这个值称为**欧拉常数**(Euler's constant)。

$$H_{N}=\sum_{i=1}^N {\frac {1}{i}}\approx \log_{e}N$$

以下两个公式只不过是一般的代数运算。

$$\sum_{i=1}^N f(N)=Nf(N)$$
$$\sum_{i=n_{0}}^N f(i)=\sum_{i=1}^N f(i)-\sum_{i=1}^{n_{0}=0} f(i)$$

**1.2.4 模运算**

如果$N$整除$A-B$，那么我们就说$A$与$B$模$N$同余（congruent），记为$A\equiv B(mod N)$。直观地看，这意味着无论$A$还是$B$被$N$去除，所得到的余数都是相同的。于是,$81\equiv 61\equiv 1(mod 10)$。如同等号的情形一样，若$A\equiv B(mod N)$，则$A+C\equiv B+C(mod N)$以及$AD\equiv BD(mod N)$。

有许多的定理适用于模运算，其中有一些特别要用到数论来证明。我们将谨慎地使用模运算，这样，前面的一些定理也就足够了。

**1.2.5 证明方法**

证明数据结构分析中的结论的两个最常用的方法是归纳法和反证法（偶尔也被迫用到只有教授们才使用的证明方法）。证明一个定理不成立的最好方法是举出一个反例。

**归纳法证明**

由归纳法进行的证明有两个标准的部分。第一步是证明**基准情形**（base case），就是确定定理对某个（某些）小的（通常是退化的）值的正确性；这一步几乎总是很简单的。接着，进行**归纳假设**（inductive hypothesis）。一般来说，这意味着假设定理对直到某个有限数$k$的所有情况都是成立的。然后使用这个假设证明定理对下一个值（通常是$k+1$）也是成立的。至此定理得证（在$k$是有限的情形下）。

作为一个例子，我们证明斐波那契数，$F_0=1$,$F_1=1$,$F_2=2$,$F_3=3$,$F_4=5$,……,$F_i=F_{i-1}+F_{i-2}$，对$i\geq 1$,满足$F_i＜(5/3)^i$。(有些定义规定$F_0=0$，这不过将该级数做了一次平移)为了证明这个不等式，我们首先验证定理对平凡的情形成立。容易验证$F_1=1＜\frac{5}{3}$及$F_2=2＜\frac{25}{9}$；这就证明了基准情形。假设定理对于$i=1,2,\ldots,k$成立；这就是归纳假设。为了证明定理，我们须要证明$F_{k+1}＜(\frac {5}{3})^{k+1}$。根据定义我们有

$$F_{k+1}=F_{k}+F_{k-1}$$

将归纳假设用于等号右边，我们得到

\begin{align}
F_{k+1} &＜(5/3)^{k}+(5/3)^{k-1} \\
& ＜ (3/5)(5/3)^{k+1}+(3/5)^{2}(5/3)^{k-1} \\
& ＜ (3/5)(5/3)^{k+1}+(9/25)(5/3)^{k-1}
\end{align}

化简后为

\begin{align}
F_{k-1} &＜(3/5-9/25)(5/3)^{k+1}\\
&＜(24/25)(5/3)^{k-1}\\
&＜(5/3)^{k+1}
\end{align}

这就证明了这个定理

在第二个例子中，我们证明下面的定理

**定理1.3**

如果$N\geq 1$,则$\sum_{i=1}^N {i^2}=\frac {N(N+1)(2N+1)}{6}$

**证明**：用数学归纳法证明，对于基准情形，容易看到，当$N=1$时，定理成立。对于归纳假设，我们设定理对$1\leq k\leq N$成立。我们将在该假设下证明定理对于$N+1$也是成立的。

我们有

$$\sum_{i=1}^{N+1} {i^2}=\sum_{i=1}^N {i^2}+(N+1)^2$$

应用归纳假设我们得到

\begin{align}
\sum_{i=1}^{N+1} {i^2} &=\frac {N(N+1)(2N+1)}{6}+(N+1)^2\\
&=(N+1)\left[\frac {N(2N+1)}{6}+(N+1) \right]\\
&=(N+1)\frac {2N^2+7N+6}{6}\\
&=\frac {(N+1)(N+2)(2N+3)}{6}
\end{align}

因此

$$\sum_{i=1}^{N+1} {i^2}=\frac{(N+1)\left[(N+1)+1\right]\left[(2(N+1)+1\right]}{6}$$

定理得证

**同过反例证明**

公式$F_{k}\leq k^2$不成立。证明这个结论最容易的方法就是计算$F_{11}＞ 11^2$。

**反证法证明**

反证法证明是通过假设定理不成立，然后证明该假设导致某个已知的性质不成立，从而说明原假设是错误的。一个经典的例子是证明存在无穷多个素数。为了证明这个结论，我们假设定理不成立。于是，存在某个最大的素数$P_k$。令$P_1,P_2,\ldots,P_k$是依序排列的所有素数并考虑

$$N=P_{1}P_{2}P_{3}\ldots P_{k}+1$$

显然，$N$是比$P_k$大的数，根据假设$N$不是素数。可是，$P_1,P_2,\ldots,P_k$都不能整除$N$，因为除得的结果总有余数1。这就产生了一个矛盾，因为对于每一个整数来说，要么是素数，要么是素数的乘积。因此$P_k$是最大素数的原假设是不成立的，这意味着定理成立。

### 1.3 递归简论

我们熟悉的大多数数学函数是由一个简单公式描述的。例如，我们可以利用公式

$$C=5(F-32)/9$$

把华氏温度转换成摄氏温度。有了这个公式，写一个$C$函数就太简单了。除去程序中的说明和大括号外，可以将这一行公式翻译成一行$C$程序。

有时候数学函数以不太标准的形式来定义。作为一个例子，我们可以在非负整数集上定义一个函数$F$，它满足$F(0)=0$且$F(X)=2F(X-1)+X^2$。从这个定义中，我们看到$F(1)=1,F(2)=6,F(3)=21$,以及$F(4)=58$。当一个函数用它自己定义时就称为是**递归**（recursive）的。$C$允许函数是递归的。但是重要的是记住，$C$仅仅提供了一种遵循递归思想的一种实现方式。不是所有的数学递归函数都能有效地（正确地）由$C$的递归模拟所来实现的。图1-2展示了函数$F$的递归实现。

                        int
                        F(int X)
                        {
                 /*1*/     if(X==0)
                 /*2*/        return 0;
                           else
                 /*3*/        return 2*F(X-1)+X*X;
                         }

第一行和第二行处理**基准情形**（base case)，即此时函数的值可以直接得到而不需要通过递归求解。正如，若“$F(X)=2F(X-1)+X^2$”没有“$F(0)=0$”这个基准条件，则在数学上是没有意义的。$C$的递归程序若无基准情况，也是毫无意义的。第三行执行的是递归调用。

关于递归，有几个重要并且容易混淆的地方。一个常见的问题是：它是否就是循环逻辑（cicular logic)？答案是：虽然我们用函数本身来定义一个函数，但是我们并没有用函数本身定义函数的一个特定实例。换句话说，通过$F(5)$求得$F(5)$才是循环的。而通过使用$F(4)$来求的$F(5)$的值并不是循环的。当然，除非$F(4)$的值又需要用到对$F(5)$的计算。现在最重要的两个问题恐怕就是“如何”和“为什么”的问题了。这两个问题将会在第三章正式解决，而在这，我们将给出一个不完全的描述。

*对数值计算使用递归通常不是一个好办法，我们只在解释基本论点时这么做。

事实上，递归调用在处理上与其他调用并没有什么不同。如果以参数4的值调用函数$F$，那么程序的第三行要求计算$2F(3)+4\ast 4$。这样就要执行一个计算$F(3)$的调用，这就要求要对$2F(2)+3\ast 3$。因此又要执行另一个计算$F(2)$的调用，而这又意味着必须求出$2F(1)+2\ast 2$的值。为此，通过计算$2F(0)+1\ast 1$而得到$F(1)$。此时，$F(0)$必须被赋值。由于这是一个基准情形，因此我们已知$F(0)$的值。从而$F(1)$的计算得以完成，其结果为1。然后，$F(2)$、$F(3)$以及最后的$F(4)$的值都能够计算出来。跟踪挂起的函数调用（虽然这些调用已经开始，但是正等待着递归调用来完成）以及它们中变量的记录工作都是由计算机自动完成的。然而，重要的问题在于，递归调用将会反复进行直到基准情形出现。例如，计算$F(-1)$的值将导致调用$F(-2)$、$F(-3)$等等。由于这将不可能出现基准情形，因此程序也就不可能计算出答案。偶尔还可能发生更加微妙的错误，我们将其展示在图1-3中。图1-3中程序的这种错误是：第三行上的$Bad(1)$用$Bad(1)$来定义了。显然，$Bad(1)$究竟等于多少，这个定义给不出任何的线索。因此计算机会反复调用$Bad(1)$以期望解出它的值。最后，计算机的记录系统将会将空间耗尽，导致程序的崩溃。一般来说，我们会说该函数对一个特殊情形无效，而在其他情形下是正确的。但是，对于此处来说并不正确，因为$Bad(2)$需要调用$Bad(1)$，因此，也无法求得$Bad(2)$的值。不仅如此，$Bad(3)$、$Bad(4)$和$Bad(5)$都要调用$Bad(2)$，$Bad(2)$的值无法求得，它们的值也就不能求出。事实上，除了0之外，这个程度对任何的$N$都不能算出结果。对于含有递归函数的程序，不存在“特殊情况”。

                         int
                         Bad(unsigned int N)
                         {
               /*1*/         if(N==0)
               /*2*/            return
                             else
               /*3*/            return Bad(N/3+1)+N-1
                          }

**1.基准情形**（base case）。必须总要有某些基准的情形，它们不用递归就能求解。

**2.不断推进**（making progress)。对于那些需要递归求解的情形，递归调用必须能够朝着向基本情形推进。

在这本书里我们将用递归解决一些问题，我们考虑一本大字典作为非数学应用的一个例子。词典中的词都是用其他的词定义的。当我们需要查找一个单词的时候，我们不理解对该词的解释，于是我们不得不再查出现在解释中的一些词。而对这些词解释中的某些词我们又不理解，因此我们还要继续这种搜索。因为，词典是有限的，所以实际上，要么我们最终查到一个词，使我们明白解释中的所有单词（从而理解这里的解释，并按照查找的路径回头理解其余的解释）；要么我们发现这个解释形成一个循环，无法明白其中的意思，或者在解释中需要我们理解的某个单词不在这本词典里。

我们这样理解这些单词的递归策略：如果我们知道一个单词的含义，那么就算我们成功；否则，我们就在词典里查找这个单词。如果我们理解对该词解释中的所有单词，那么又算我们成功；否则递归地查找一些我们不认识的单词来“算出”对该单词的解释。如果词典编纂得完美无瑕，那么这个过程就能够终止；如果其中一个单词没有查找到或者是行程循环定义（解释），那么这个过程的循环将不会终止。

**打印输出数**

假设我们有一个正整数$N$并希望将他打印出来。我们例程的名字是$PrintOut(N)$。假设仅有现成的I/O例程，只处理单个数字并将其输出到终端。我们将这个历程命名为$PrintDigit$；例如“$PrintDigit(4)$”将输出一个“4”到终端。

递归对该问题提供一个非常简洁的解，为打印“76234”，我们需要首先打印“7623”，然后再打印出“4”。第二步利用语句“$PrintDigit(4)$”能够很容易地实现，但是第一步确不比原问题简单多少。实际上，它们是同一个问题。因此我们可以用语句“$PrintDigit(N/10)$”递归地解决它。

这告诉我们如何去解决一般的问题，不过我们仍旧需要去确认程序不是无限循环的。由于我们还没有定义一个基准情形，因此很清楚，我们依旧还有一些事情要去做。如果$0\leq N＜10$,我们的基准情形为“$PrintDigit(N)$”。现在，“$PrintDigit(4)$”已经对每一个从0到9的正整数做出定义，而更大的正整数则通过较小的正整数定义。因此不存在循环定义，整个过程如图1-4所示。

*过程（procedure)即返回值为void型的函数。

                          void
                          PrintOut(unsigned int N) /* Print nonnegative*/
                          {
                               if(N>=10)
                                  PrintOut(N/10);
                               PrintDihit(N%10);
                          }

然而我们没有尝试努力去高效地解决这个问题。我们本可以避免使用mod操作的（它的耗费很大），因为$N%10=N-[\frac {N}{10}]*10$。

*$[X]$意为小于或等于$X$的最大整数。

**递归和归纳**

我们将用归纳法对上述数字递归打印的程序给予更加严格的证明。

**定理 1.4**

对于$N\geq 0$，数的递归打印算法是正确的。

**证明**

首先，如果$N$只有一位数字，那么这个程序显然是正确的，因为它仅仅调用了$PrintDigit$。假设$PrintOut$对所有$k$位或者位数更少的数均能够正常工作。那么一个$k+1$位的数字可以通过前$k$位数字后跟一位最低位数字来表示。前$k$位数字恰好是$[N/10]$，假设它能够被正确地打印出来，而最后一位数字是$N mod 10$，因此该程序能够正确打印出任意的$k+1$位的数。于是，根据归纳法，所有的数字都能够正确地打印。

这个证明看起来可能有点奇怪，因为实际上相当于是算法的描述。它阐述了在设计递归程序时，可以假设同一个问题的较小实例均可以正确运行。这些小问题的解可以通过递归“奇迹般”地得到，递归程序只要将这些解结合起来，就可以得到当前问题的解。其数学根据是归纳法，我们给出递归的第三个法则：

**3.设计法则**（design rule）。假设所有的递归调用均能够工作。这是一条重要的法则，因为它意味着，当设计递归调用时，一般没有必要知道内存管理的细节，不必试图追踪大量的递归调用。追踪实际的递归调用序列常常是非常困难的。当然，在许多情况下，这正体现了递归的好处，因为计算机能够算出许多复杂的细节。

递归的主要问题还有隐藏的系统开销。虽然这些开销几乎都是合理的（因为递归程序不仅简化了算法设计，而且也有助于给出更加简洁的代码），但是递归绝不应该作为简单$for$循环的替代物。我们将在3.3节更仔细地讨论递归设计的系统开销。

当编写递归例程的时候，关键要牢记递归的四条基本法则。

**1.基准情形**。必须有一些基准情形，它无须递归就能够解出。

**2.不断推进**。对于那些需要递归求解的情形，每一次递归调用都必须要使求解情况朝接近基准情形的方向推进。

**3.设计法则**。假设所有的递归调用都能运行。

**4.合成效益法则**（compound interest rule)。在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。

第四条法则的正确性我们将在后面的章节给予证明。使用递归来计算如斐波那契数之类简单数学函数的值一般不是一个好主意，其根据就是第四条法则。只要记住这些法则，递归程序设计就应该简单明了了。

### 总结

这一章为本书的其他部分搭建了一个基本的平台。对于面临大量输入的算法，它所花费的时间是判断好坏的一个重要标准。当然，正确性是最重要的。运算速度是相对的。对于一个问题在一台机器上是快速的算法，有可能对另一个问题或者在不同的机器上就变成了慢的算法。我们将在下一章讲述这个问题，并将用这里讨论的数学概念建立一个正式的模型。
                         

#sssssss
